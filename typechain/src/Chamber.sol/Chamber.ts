/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export interface ChamberInterface extends utils.Interface {
  functions: {
    "NFT()": FunctionFragment;
    "approveProposal(uint256,uint256)": FunctionFragment;
    "createProposal(address[],uint256[],bytes[])": FunctionFragment;
    "getAdjacent(uint256,bool)": FunctionFragment;
    "getData(uint256)": FunctionFragment;
    "getNext(uint256)": FunctionFragment;
    "getNextNode(uint256)": FunctionFragment;
    "getPrev(uint256)": FunctionFragment;
    "getPreviousNode(uint256)": FunctionFragment;
    "getUserStakeIndividualNFT(address,uint256)": FunctionFragment;
    "head()": FunctionFragment;
    "helperView()": FunctionFragment;
    "inList(uint256)": FunctionFragment;
    "isInitialized()": FunctionFragment;
    "leaders()": FunctionFragment;
    "list(uint256,bool)": FunctionFragment;
    "migrate(uint256,uint256,uint256)": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "proposalCount()": FunctionFragment;
    "proposals(uint256)": FunctionFragment;
    "quorum()": FunctionFragment;
    "size()": FunctionFragment;
    "stake(uint256,uint256)": FunctionFragment;
    "stakingToken()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "tokenIdData(uint256)": FunctionFragment;
    "totalStake(uint256)": FunctionFragment;
    "unstake(uint256,uint256)": FunctionFragment;
    "userStakeIndividualNFT(address,uint256)": FunctionFragment;
    "viewRankings()": FunctionFragment;
    "viewRankingsAll()": FunctionFragment;
    "voted(uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "NFT"
      | "approveProposal"
      | "createProposal"
      | "getAdjacent"
      | "getData"
      | "getNext"
      | "getNextNode"
      | "getPrev"
      | "getPreviousNode"
      | "getUserStakeIndividualNFT"
      | "head"
      | "helperView"
      | "inList"
      | "isInitialized"
      | "leaders"
      | "list"
      | "migrate"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "onERC721Received"
      | "proposalCount"
      | "proposals"
      | "quorum"
      | "size"
      | "stake"
      | "stakingToken"
      | "supportsInterface"
      | "tokenIdData"
      | "totalStake"
      | "unstake"
      | "userStakeIndividualNFT"
      | "viewRankings"
      | "viewRankingsAll"
      | "voted"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "NFT", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "approveProposal",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createProposal",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAdjacent",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "getData",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNext",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextNode",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPrev",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPreviousNode",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserStakeIndividualNFT",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "head", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "helperView",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "inList",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isInitialized",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "leaders", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "list",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "migrate",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposals",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "quorum", values?: undefined): string;
  encodeFunctionData(functionFragment: "size", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenIdData",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userStakeIndividualNFT",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "viewRankings",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "viewRankingsAll",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "voted",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "NFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approveProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAdjacent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getData", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getNext", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNextNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPrev", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPreviousNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserStakeIndividualNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "head", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "helperView", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "inList", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isInitialized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "leaders", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "list", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "migrate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proposals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "quorum", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "size", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakingToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenIdData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "totalStake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userStakeIndividualNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewRankings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewRankingsAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "voted", data: BytesLike): Result;

  events: {
    "Log(uint256,uint256,uint256,uint256)": EventFragment;
    "ProposalApproved(uint256,uint256,uint256)": EventFragment;
    "ProposalCreated(uint256,address[],uint256[],bytes[],uint256[])": EventFragment;
    "ProposalExecuted(uint256)": EventFragment;
    "ReceivedEther(address,uint256)": EventFragment;
    "Staked(address,uint256,uint256)": EventFragment;
    "Unstaked(address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Log"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReceivedEther"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unstaked"): EventFragment;
}

export interface LogEventObject {
  arg0: BigNumber;
  arg1: BigNumber;
  arg2: BigNumber;
  arg3: BigNumber;
}
export type LogEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  LogEventObject
>;

export type LogEventFilter = TypedEventFilter<LogEvent>;

export interface ProposalApprovedEventObject {
  proposalId: BigNumber;
  nftId: BigNumber;
  approvals: BigNumber;
}
export type ProposalApprovedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  ProposalApprovedEventObject
>;

export type ProposalApprovedEventFilter =
  TypedEventFilter<ProposalApprovedEvent>;

export interface ProposalCreatedEventObject {
  proposalId: BigNumber;
  target: string[];
  value: BigNumber[];
  data: string[];
  voters: BigNumber[];
}
export type ProposalCreatedEvent = TypedEvent<
  [BigNumber, string[], BigNumber[], string[], BigNumber[]],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalExecutedEventObject {
  proposalId: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<
  [BigNumber],
  ProposalExecutedEventObject
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export interface ReceivedEtherEventObject {
  sender: string;
  value: BigNumber;
}
export type ReceivedEtherEvent = TypedEvent<
  [string, BigNumber],
  ReceivedEtherEventObject
>;

export type ReceivedEtherEventFilter = TypedEventFilter<ReceivedEtherEvent>;

export interface StakedEventObject {
  staker: string;
  amt: BigNumber;
  tokenId: BigNumber;
}
export type StakedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  StakedEventObject
>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface UnstakedEventObject {
  staker: string;
  amt: BigNumber;
  tokenId: BigNumber;
}
export type UnstakedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  UnstakedEventObject
>;

export type UnstakedEventFilter = TypedEventFilter<UnstakedEvent>;

export interface Chamber extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ChamberInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    NFT(overrides?: CallOverrides): Promise<[string]>;

    approveProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createProposal(
      _target: PromiseOrValue<string>[],
      _value: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAdjacent(
      tokenId: PromiseOrValue<BigNumberish>,
      direction: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getData(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        exists: boolean;
        prev: BigNumber;
        next: BigNumber;
      }
    >;

    getNext(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber] & { exists: boolean; next: BigNumber }>;

    getNextNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getPrev(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber] & { exists: boolean; prev: BigNumber }>;

    getPreviousNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getUserStakeIndividualNFT(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    head(overrides?: CallOverrides): Promise<[BigNumber]>;

    helperView(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    inList(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { exists: boolean }>;

    isInitialized(
      overrides?: CallOverrides
    ): Promise<[boolean] & { initialized: boolean }>;

    leaders(overrides?: CallOverrides): Promise<[number]>;

    list(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    migrate(
      amt: PromiseOrValue<BigNumberish>,
      fromTokenId: PromiseOrValue<BigNumberish>,
      toTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, number] & { approvals: BigNumber; state: number }>;

    quorum(overrides?: CallOverrides): Promise<[number]>;

    size(overrides?: CallOverrides): Promise<[BigNumber]>;

    stake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<[string]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    tokenIdData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { stake: BigNumber }>;

    totalStake(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    unstake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userStakeIndividualNFT(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    viewRankings(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        rankings: BigNumber[];
        stakes: BigNumber[];
      }
    >;

    viewRankingsAll(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    voted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  NFT(overrides?: CallOverrides): Promise<string>;

  approveProposal(
    proposalId: PromiseOrValue<BigNumberish>,
    nftId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createProposal(
    _target: PromiseOrValue<string>[],
    _value: PromiseOrValue<BigNumberish>[],
    _data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAdjacent(
    tokenId: PromiseOrValue<BigNumberish>,
    direction: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber]>;

  getData(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber, BigNumber] & {
      exists: boolean;
      prev: BigNumber;
      next: BigNumber;
    }
  >;

  getNext(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber] & { exists: boolean; next: BigNumber }>;

  getNextNode(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber]>;

  getPrev(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber] & { exists: boolean; prev: BigNumber }>;

  getPreviousNode(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber]>;

  getUserStakeIndividualNFT(
    user: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  head(overrides?: CallOverrides): Promise<BigNumber>;

  helperView(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  inList(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isInitialized(overrides?: CallOverrides): Promise<boolean>;

  leaders(overrides?: CallOverrides): Promise<number>;

  list(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  migrate(
    amt: PromiseOrValue<BigNumberish>,
    fromTokenId: PromiseOrValue<BigNumberish>,
    toTokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC1155BatchReceived(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>[],
    arg3: PromiseOrValue<BigNumberish>[],
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  proposals(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, number] & { approvals: BigNumber; state: number }>;

  quorum(overrides?: CallOverrides): Promise<number>;

  size(overrides?: CallOverrides): Promise<BigNumber>;

  stake(
    amt: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakingToken(overrides?: CallOverrides): Promise<string>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  tokenIdData(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalStake(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  unstake(
    amt: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  userStakeIndividualNFT(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  viewRankings(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[]] & { rankings: BigNumber[]; stakes: BigNumber[] }
  >;

  viewRankingsAll(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  voted(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    NFT(overrides?: CallOverrides): Promise<string>;

    approveProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createProposal(
      _target: PromiseOrValue<string>[],
      _value: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    getAdjacent(
      tokenId: PromiseOrValue<BigNumberish>,
      direction: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getData(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        exists: boolean;
        prev: BigNumber;
        next: BigNumber;
      }
    >;

    getNext(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber] & { exists: boolean; next: BigNumber }>;

    getNextNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getPrev(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber] & { exists: boolean; prev: BigNumber }>;

    getPreviousNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getUserStakeIndividualNFT(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    head(overrides?: CallOverrides): Promise<BigNumber>;

    helperView(overrides?: CallOverrides): Promise<void>;

    inList(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isInitialized(overrides?: CallOverrides): Promise<boolean>;

    leaders(overrides?: CallOverrides): Promise<number>;

    list(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    migrate(
      amt: PromiseOrValue<BigNumberish>,
      fromTokenId: PromiseOrValue<BigNumberish>,
      toTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, number] & { approvals: BigNumber; state: number }>;

    quorum(overrides?: CallOverrides): Promise<number>;

    size(overrides?: CallOverrides): Promise<BigNumber>;

    stake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakingToken(overrides?: CallOverrides): Promise<string>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenIdData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStake(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    userStakeIndividualNFT(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewRankings(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        rankings: BigNumber[];
        stakes: BigNumber[];
      }
    >;

    viewRankingsAll(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        rankings: BigNumber[];
        stakes: BigNumber[];
      }
    >;

    voted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "Log(uint256,uint256,uint256,uint256)"(
      arg0?: null,
      arg1?: null,
      arg2?: null,
      arg3?: null
    ): LogEventFilter;
    Log(arg0?: null, arg1?: null, arg2?: null, arg3?: null): LogEventFilter;

    "ProposalApproved(uint256,uint256,uint256)"(
      proposalId?: null,
      nftId?: null,
      approvals?: null
    ): ProposalApprovedEventFilter;
    ProposalApproved(
      proposalId?: null,
      nftId?: null,
      approvals?: null
    ): ProposalApprovedEventFilter;

    "ProposalCreated(uint256,address[],uint256[],bytes[],uint256[])"(
      proposalId?: null,
      target?: null,
      value?: null,
      data?: null,
      voters?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      proposalId?: null,
      target?: null,
      value?: null,
      data?: null,
      voters?: null
    ): ProposalCreatedEventFilter;

    "ProposalExecuted(uint256)"(proposalId?: null): ProposalExecutedEventFilter;
    ProposalExecuted(proposalId?: null): ProposalExecutedEventFilter;

    "ReceivedEther(address,uint256)"(
      sender?: PromiseOrValue<string> | null,
      value?: null
    ): ReceivedEtherEventFilter;
    ReceivedEther(
      sender?: PromiseOrValue<string> | null,
      value?: null
    ): ReceivedEtherEventFilter;

    "Staked(address,uint256,uint256)"(
      staker?: null,
      amt?: null,
      tokenId?: null
    ): StakedEventFilter;
    Staked(staker?: null, amt?: null, tokenId?: null): StakedEventFilter;

    "Unstaked(address,uint256,uint256)"(
      staker?: null,
      amt?: null,
      tokenId?: null
    ): UnstakedEventFilter;
    Unstaked(staker?: null, amt?: null, tokenId?: null): UnstakedEventFilter;
  };

  estimateGas: {
    NFT(overrides?: CallOverrides): Promise<BigNumber>;

    approveProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createProposal(
      _target: PromiseOrValue<string>[],
      _value: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAdjacent(
      tokenId: PromiseOrValue<BigNumberish>,
      direction: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getData(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNext(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPrev(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPreviousNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserStakeIndividualNFT(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    head(overrides?: CallOverrides): Promise<BigNumber>;

    helperView(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    inList(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isInitialized(overrides?: CallOverrides): Promise<BigNumber>;

    leaders(overrides?: CallOverrides): Promise<BigNumber>;

    list(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    migrate(
      amt: PromiseOrValue<BigNumberish>,
      fromTokenId: PromiseOrValue<BigNumberish>,
      toTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    quorum(overrides?: CallOverrides): Promise<BigNumber>;

    size(overrides?: CallOverrides): Promise<BigNumber>;

    stake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakingToken(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenIdData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalStake(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    userStakeIndividualNFT(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewRankings(overrides?: CallOverrides): Promise<BigNumber>;

    viewRankingsAll(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    voted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    NFT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createProposal(
      _target: PromiseOrValue<string>[],
      _value: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAdjacent(
      tokenId: PromiseOrValue<BigNumberish>,
      direction: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getData(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNext(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPrev(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPreviousNode(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserStakeIndividualNFT(
      user: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    head(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    helperView(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    inList(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isInitialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    leaders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    list(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    migrate(
      amt: PromiseOrValue<BigNumberish>,
      fromTokenId: PromiseOrValue<BigNumberish>,
      toTokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    quorum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    size(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenIdData(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalStake(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unstake(
      amt: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userStakeIndividualNFT(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewRankings(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    viewRankingsAll(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    voted(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
